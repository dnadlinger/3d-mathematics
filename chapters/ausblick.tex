% Kapitel 'Ausblick'
\chapter{Ausblick}

% @fix: und was in den anderen?
In den letzten beiden Kapiteln wurden alle Transformationen behandelt, die nötig sind, um die World, View, Projection und Viewport Matrix zu erzeugen. Nachdem die Vertices diese Transformationen durchlaufen haben, liegen ihre Positionen in Bildschirmkoordinaten vor, die Dreiecke müssen also \enquote{nur noch} gezeichnet werden.

Die Anführungszeichen sind mit Bedacht gesetzt, denn die Rasterisierung erscheint höchstens aus einem mathematischen Blickwinkel einfach. Aus programmiertechnischer Sicht ist das Füllen, wie in Kapitel \ref{grafikgrundlagen} angedeutet, alles andere als trivial. Ein guter Teil der Komplexität entsteht dadurch, dass die Operationen alle äußerst schnell ausgeführt werden müssen, damit das Programm insgesamt eine akzeptable Leistung erbringt -- man bedenke, dass die meisten aktuellen Bildschirme aus über $10^6$ Bildpunkten bestehen, deren Farbwerte mindestens 20-30 Mal pro Sekunde berechnet werden müssen.

Es müssen also beispielsweise Algorithmen gefunden werden, mit denen die Größen, die für die Farbberechnung erforderlich sind, für alle Pixel eines Dreiecks möglichst effizient aus denen der Vertices interpoliert werden können. Daneben versucht man auch, die Anzahl der \enquote{unnötigerweise} berechneten Pixel zu reduzieren, indem man Pixel, die später sowieso von einem näher bei der Kamera liegenden Dreieck überdeckt werden, möglichst früh aussortiert, etc.

Dabei handelt es sich aber um Fragestellungen, deren Beantwortung den Rahmen dieser Arbeit in zweifacher Hinsicht sprengen würde: Zum einen, weil es sich dabei keineswegs um allgemeine Grundlagen handelt -- die diesbezüglichen Ansätze der Grafikkartenhersteller unterschieden sich teilweise erheblich (und tun dies zum Teil auch heute noch). Zum anderen, weil die Probleme ohne Rücksichtnahme auf die internen Arbeitsweisen und Abläufe eines Computers kaum sinnvoll zu behandeln sind, was wiederum nicht zu der mathematischen Ausrichtung dieser Arbeit passen würde.

Weiters muss man sich bewusst sein, dass die hier behandelten Themen, wie auch schon im Titel der Arbeit ausgedrückt, lediglich die Grundlagen der 3D-Grafik sind. Es ist zwar möglich, rein mit diesen Hilfsmitteln ein Programm zu erstellen, das eine rudimentäre Darstellung einer Szene erzeugt (wie etwa das Beispielprogramm zu dieser Arbeit). Es fehlen jedoch noch viele der Fähigkeiten, welche die 3D-Grafik in den letzten Jahren erst so richtig interessant werden ließen und beispielsweise ihren Einsatz in Computerspielen überhaupt erst ermöglichen.

Dazu zählen einerseits die Techniken, welche die gerenderten Bilder erst halbwegs realistisch erscheinen lassen, also zum Bespiel die in Kapitel \ref{texturing} kurz erwähnten Texturierungstechniken zur Simulation von Details oder Techniken zur Darstellung von Reflexionen und Tiefenunschärfe.

Andererseits sind dies die Techniken, die nötig sind, um größere Mengen an Objekten sinnvoll verwalten zu können. Je nach Einsatzgebiet werden die Daten hier in speziellen Strukturen gespeichert, die den Raum nach einem bestimmten Prinzip unterteilen (etwa in sogenannten Octrees oder BSP-Trees). Zusammen mit anderen Techniken wie zum Beispiel dem Portal-Rendering können so große Teile der eine bestimmte Kameraposition irrelevante Objekte gleich im Vornhinein ausgeschlossen werden. Diese Techniken ermöglichen erst, größere Umgebungen ohne \enquote{künstliche}, für den Spieler sichtbare Unterteilungen in Computerspiele zu integrieren.

Außerdem gehört zu einer Simulation einer dreidimensionalen Welt ja nicht nur die Grafikausgabe, sondern es müssen auch zahlreiche andere Berechnungen im dreidimensionalen Raum ablaufen. Für Computerspiele ist hier besonders die Kollisionserkennung wichtig, bei der möglichst effizient festgestellt werden soll, ob ein Objekt irgendein anderes Objekt der Szene berührt, was wegen der oft hohen Anzahl an Objekten in einer Szene keineswegs trivial ist.
% @missing: Animation (SLERP)

Schließlich darf man bei der Auseinandersetzung mit der 3D-Grafik nicht vergessen, dass auf diesem Gebiet zur Zeit ein sehr hohes Innovationstempo herrscht. So könnte ich mir zum Beispiel gut vorstellen, dass in zehn Jahren alle Grafikkarten und Spielkonsolen nach einem völlig anderen Verfahren als dem hier behandelten arbeiten werden. Im Moment werden im Rennen um die Nachfolgeschaft vor allem den in Kapitel \ref{grafikgrundlagen} kurz erwähnten Voxel-basierenden Methoden gute Chancen eingeräumt.